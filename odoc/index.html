<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (odoc.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">odoc</a> &#x00BB; index</nav></header><h1 id="top"><a href="#top" class="anchor"></a>odoc</h1><p>The documentation compiler for OCaml and Reason.</p><ol><li><a href="#overview">What is <code>odoc</code>?</a></li><li><a href="#getting-started">Getting Started with <code>odoc</code></a></li><li><a href="high-level-flow.html">How does <code>odoc</code> work?</a></li><li><a href="using-odoc.html">Using <code>odoc</code></a></li><li><a href="system-integrations.html">Integrating <code>odoc</code> into your Build System</a></li><li><a href="odoc-internals.html">Understanding <code>odoc</code> Internals</a></li><li><a href="contributing.html">Contributing to <code>odoc</code></a></li></ol><h2 id="overview"><a href="#overview" class="anchor"></a>What is <code>odoc</code>?</h2><p><code>odoc</code> is not your ordinary documentation tool.</p><p>It's built from the ground up to be build-tool friendly, and it focuses on parallelism and caching. Instead of source code, it works with <i>compilation units</i>; that is, it works on compiler outputs and turns them into compiled documentation, which then becomes gorgeous HTML.</p><p>Compiled documentation appears in the form of <code>.odoc</code> files, which consist of an intermediary representation that is currrently internal and subject to change.</p><p>A regular <code>odoc</code> execution transforms <code>.cmt</code>, <code>.cmti</code>, and <code>.mld</code> files into <code>.odoc</code> files, and then turns those into <code>.html</code> files. Roughly like this:</p><pre><code class="ml">cmti_and_mld_files |&gt; compile_to_odoc |&gt; compile_to_html</code></pre><p>This means that an <code>intro.mld</code> file will be compiled to <code>page-intro.odoc</code> which in turn will become <code>intro.html</code>.</p><p>Similarly, a <code>Game.cmti</code> will be compiled to <code>Game.odoc</code> which in turn will become <code>Game/index.html</code>.</p><h2 id="getting-started"><a href="#getting-started" class="anchor"></a>Getting Started with <code>odoc</code></h2><p>You can install <code>odoc</code> today through <code>opam</code>:</p><pre><code class="ml">$ opam install odoc</code></pre><h3 id="usage-ocaml"><a href="#usage-ocaml" class="anchor"></a>...using OCaml</h3><p>The easiest way to use odoc right now is by having Dune drive it. This command should work in most Dune projects out of the box:</p><pre><code class="ml">dune build @doc</code></pre><p>The generated docs can be found at <code>./_build/default/_doc/_html/index.html</code>.</p><h3 id="usage-bucklescript"><a href="#usage-bucklescript" class="anchor"></a>...using BuckleScript</h3><p>While the BuckleScript/Reason toolchain relies on <code>npm</code>, <code>odoc</code> at the moment needs to be used from a working OCaml toolchain.</p><p>This means we follow the same installation than above, but using the <code>4.02.3+buckle-master</code> version of the OCaml compiler.</p><pre><code class="ml">$ opam switch 4.02.3+buckle-master
$ eval `opam config env`
$ opam install odoc</code></pre><p>Now with that working, we can point <code>odoc</code> to the path where BuckleScript saves the compiled code that we can use to generate our documentation. This path is <code>$root/lib/bs</code>.</p><p>In there you'll find your <code>.cmt</code> and <code>.cmti</code> files.</p><p>You can now compile each one of them from <code>.cmt[i]</code> to <code>.odoc</code> and from <code>.odoc</code> to <code>.html</code>.</p><p>The following script can help you get started:</p><pre><code class="ml">#!/bin/bash

readonly PKG=$1
readonly DOCS=$2

readonly ODOC=$(which odoc)
readonly LIB=./lib/bs/src

readonly CMT_FILES=$(find ${LIB} -name &quot;*.cmti&quot;)
readonly ODOC_FILES=$(echo ${CMT_FILES} | sed &quot;s/cmti/odoc/g&quot;)

echo &quot;&lt;&lt; Compiling docs...&quot;
for file in ${CMT_FILES}; do
  ${ODOC} compile \
    -I ${LIB} \
    --pkg=${PKG} \
    ${file}
done
echo &quot;&gt;&gt; Done!&quot;

echo &quot;&lt;&lt; Generating HTML...&quot;
for file in ${ODOC_FILES}; do
  ${ODOC} html \
    -I ${LIB} \
    -o ${DOCS} \
    --syntax=re \
    --semantic-uris \
    ${file}
done
echo &quot;&gt;&gt; Done!&quot;</code></pre><p>And you can call it like:</p><pre><code class="ml">$ ./mk-docs.sh MyPackageName ${path_to_docs_folder}
&lt;&lt; Compiling docs...
&gt;&gt; Done!
&lt;&lt; Generating HTML...
&gt;&gt; Done!</code></pre></div></body></html>